/**
 * Функциональное тестирование проверяет, удовлетворяет ли результат определенным требованиям или нет. Его основная задача — подтвердить, что функциональность приложения или системы работает должным образом.
 *
 * Должно быть что-то, что определяет, что приемлемо, а что нет. Обычно это прописывается в спецификации. Это документ, описывающий ожидаемое поведение программы. Кроме того, иногда спецификации также включают реальные бизнес-сценарии, которые необходимо проверить.
 *
 * Ключевым понятием, которое представляет различные виды тестов, является тестовая пирамида. Это отличное наглядное пособие, которое показывает разные уровни теста. Он также показывает степень испытаний на каждом уровне.
 *
 * На нижних уровнях тестов больше и они проходят быстрее, так как небольшие и направлены на тестирование отдельных функций или фич. На более высоком уровне тестов меньше, так как они более сложные и объёмные, требуют больше усилий и времени. Давайте посмотрим на пирамиду снизу вверх.
 */
fun main() {
    unitTesting()
    integrationTesting()
    endToEndTesting()
    uiTesting()

    println("--- Smoke and Regression ---")

    /**
     * Smoke тестирование — это метод тестирования, вдохновленный тестированием оборудования, при котором проверяется наличие дыма от компонентов оборудования после включения питания оборудования. Smoke Testing — это минимальный набор тестов для поиска очевидных ошибок. Дымовое тестирование выполняется для проверки того, что критически важные функциональные части работают должным образом, а вся система стабильна. Нет смысла отправлять программу, не прошедшую этот тест, на более глубокое тестирование.
     *
     * Регрессионное тестирование часто проводится после дымового теста и некоторых изменений кода. Его цель — подтвердить, что эти изменения не оказали негативного влияния на существующий набор функций/функций. Регрессионные тестовые случаи могут быть получены из функциональных требований или спецификаций, руководств пользователя и выполняются вне зависимости от того, что исправили разработчики.
     *
     * Эти два типа тестов могут быть реализованы на любом уровне, поскольку разработчики могут вносить изменения на любом уровне. Это означает, что каждый раз, когда они что-то меняют, им нужно ещё раз проверить стабильна ли система и всё ли работает правильно.
     */
}

/**
 * Самый простой тип тестирования — модульное тестирование. Это требует написания тестов для каждой нетривиальной функции или метода. С его помощью можно быстро проверить, не привело ли последнее изменение кода к каким-то новым ошибкам в уже протестированных частях программы; это также облегчает обнаружение и устранение таких ошибок. Цель модульного тестирования — изолировать отдельные части программы и показать, что каждая из этих частей работает.
 */
fun unitTesting() {
    println("--- Unit testing ---")

    /**
     * Тест проходит следующие этапы:
     *
     * - Мы создаём два набора данных: вход и ожидаемый результат;
     * - Мы определяем критерии приемлемости: некоторые условия, определяющие, работает ли устройство так, как ожидается (обычно критерием приемлемости является сравнение фактического результата с ожидаемым);
     * - Мы передаём созданный входной набор данных в тестируемый модуль;
     * - Вход вызывает код тестируемого модуля;
     * - Код производит вывод;
     * - Произведённый результат проверяется по критериям приёмки, при котором фактический результат сравнивается с ожидаемым;
     * - Критерии приёмки возвращают результат: пройдено или не пройдено.
     *
     * Примечание: нет шага под названием «мы тщательно изучаем код».
     *
     * В модульном тестировании мы ничего не знаем о том, что модуль на самом деле делает с входными аргументами, но мы точно знаем, какой результат ожидается для каждого набора входных аргументов.
     */

    val x = 2
    val y = 2
    val expected = 4

    fun add(x: Int, y: Int): Int = x + y

    val output = add(x, y)

    if (expected == output) {
        println("Passed")
    } else {
        println("Failed")
    }
}

/**
 * Все сложные приложения интегрируются с какими-то другими частями, такими как базы данных, файловые системы и т. д. Таким образом, получается, что разработчикам также нужно тестировать, как все эти части будут работать вместе. Для этого и нужны интеграционные тесты.
 *
 * Они берут уже протестированные модули в качестве входных данных, группируют их в более крупные наборы, запускают тесты, определенные в плане тестирования для этих наборов, и представляют их в качестве выходных данных и входных данных для последующего тестирования системы. Цель — проверить интеграцию приложения со всеми внешними компонентами.
 *
 * Так что при таком тестировании нужно запускать не только само приложение, но и компоненты, которые будут интегрироваться. Например, если вы хотите проверить интеграцию с базой данных, вам следует запустить базу данных при выполнении тестов.
 */
fun integrationTesting() {
    println("--- Integration testing ---")
}

/**
 * После интеграционных тестов можно проверить всю систему от начала до конца. Это называется сквозным тестированием.
 *
 * Сквозное тестирование — это методология тестирования программного обеспечения, позволяющая полностью протестировать поток приложений. Целью сквозного тестирования является моделирование реального пользовательского сценария и проверка тестируемой системы, а также ее компонентов на интеграцию и целостность данных.
 *
 * Это выполняется в реальных сценариях, таких как связь приложения с оборудованием, сетью, базой данных и другими приложениями.
 *
 * Сквозные тесты очень полезны, но их выполнение дорого обходится, и их сложно поддерживать, когда они автоматизированы. Рекомендуется иметь несколько ключевых сквозных тестов и больше полагаться на типы тестирования более низкого уровня (модульные и интеграционные тесты), чтобы иметь возможность быстро выявлять новые ошибки.
 */
fun endToEndTesting() {
    println("--- End-to-end testing ---")
}

/**
 * Тестирование пользовательского интерфейса означает тестирование пользовательского интерфейса. Идея в том, что QA-инженеры имитируют действия пользователя, т.е. клики по кнопкам и ссылкам и другие действия подобного типа. Суть в том, чтобы проверить взаимодействие между компонентами. Если вы, скажем, сделали новый сайт, то во время UI-тестирования вы проверите, например, как работает поиск, могут ли пользователи заходить и выходить, как открываются разделы и так далее.
 *
 * Тестирование пользовательского интерфейса может выполняться не только разработчиками, но и пользователями. Этот тип функционального тестирования называется бета-тестированием.
 *
 * Бета-тестирование или приемочное тестирование проводится в самом конце, когда сырая или бета-версия продукта готова. Бета-тестирование — это интенсивное использование почти готовой версии продукта с целью выявления как можно большего количества ошибок до того, как продукт будет окончательно выпущен на рынок. Он требует не разработчиков, как во всех предыдущих методах тестирования, а добровольцев, которые какое-то время будут пользоваться продуктом и указывать на его недостатки.
 */
fun uiTesting() {
    println("--- UI testing ---")
}

/**
 * Функциональное тестирование проверяет, удовлетворяет ли результат определенным требованиям или нет. Его основная задача — подтвердить, что функциональность приложения или системы работает должным образом.
 *
 * Должно быть что-то, что определяет, что приемлемо, а что нет. Обычно это прописывается в спецификации. Это документ, описывающий ожидаемое поведение программы. Кроме того, иногда спецификации также включают реальные бизнес-сценарии, которые необходимо проверить.
 *
 * Ключевым понятием, которое представляет различные виды тестов, является тестовая пирамида. Это отличное наглядное пособие, которое показывает разные уровни теста. Он также показывает степень испытаний на каждом уровне.
 *
 * На нижних уровнях тестов больше и они проходят быстрее, так как небольшие и направлены на тестирование отдельных функций или фич. На более высоком уровне тестов меньше, так как они более сложные и объёмные, требуют больше усилий и времени. Давайте посмотрим на пирамиду снизу вверх.
 */
fun main() {
    unitTesting()
    integrationTesting()
    endToEndTesting()
    uiTesting()

    println("--- Smoke and Regression ---")

    /**
     * Smoke тестирование — это метод тестирования, вдохновленный тестированием оборудования, при котором проверяется наличие дыма от компонентов оборудования после включения питания оборудования. Smoke Testing — это минимальный набор тестов для поиска очевидных ошибок. Дымовое тестирование выполняется для проверки того, что критически важные функциональные части работают должным образом, а вся система стабильна. Нет смысла отправлять программу, не прошедшую этот тест, на более глубокое тестирование.
     *
     * Регрессионное тестирование часто проводится после дымового теста и некоторых изменений кода. Его цель — подтвердить, что эти изменения не оказали негативного влияния на существующий набор функций/функций. Регрессионные тестовые случаи могут быть получены из функциональных требований или спецификаций, руководств пользователя и выполняются вне зависимости от того, что исправили разработчики.
     *
     * Эти два типа тестов могут быть реализованы на любом уровне, поскольку разработчики могут вносить изменения на любом уровне. Это означает, что каждый раз, когда они что-то меняют, им нужно ещё раз проверить стабильна ли система и всё ли работает правильно.
     */
}

/**
 * Самый простой тип тестирования — модульное тестирование. Это требует написания тестов для каждой нетривиальной функции или метода. С его помощью можно быстро проверить, не привело ли последнее изменение кода к каким-то новым ошибкам в уже протестированных частях программы; это также облегчает обнаружение и устранение таких ошибок. Цель модульного тестирования — изолировать отдельные части программы и показать, что каждая из этих частей работает.
 */
fun unitTesting() {
    println("--- Unit testing ---")

    /**
     * Тест проходит следующие этапы:
     *
     * - Мы создаём два набора данных: вход и ожидаемый результат;
     * - Мы определяем критерии приемлемости: некоторые условия, определяющие, работает ли устройство так, как ожидается (обычно критерием приемлемости является сравнение фактического результата с ожидаемым);
     * - Мы передаём созданный входной набор данных в тестируемый модуль;
     * - Вход вызывает код тестируемого модуля;
     * - Код производит вывод;
     * - Произведённый результат проверяется по критериям приёмки, при котором фактический результат сравнивается с ожидаемым;
     * - Критерии приёмки возвращают результат: пройдено или не пройдено.
     *
     * Примечание: нет шага под названием «мы тщательно изучаем код».
     *
     * В модульном тестировании мы ничего не знаем о том, что модуль на самом деле делает с входными аргументами, но мы точно знаем, какой результат ожидается для каждого набора входных аргументов.
     */

    val x = 2
    val y = 2
    val expected = 4

    fun add(x: Int, y: Int): Int = x + y

    val output = add(x, y)

    if (expected == output) {
        println("Passed")
    } else {
        println("Failed")
    }

    /**
     * JUnit - фреймворк для автоматизированного модульного тестирования в Kotlin.
     *
     * Чтобы начать работу с JUnit 5, вам нужно добавить в свой проект необходимые зависимости.
     *
     * Если вы используете Gradle в качестве инструмента сборки проекта, добавьте следующую зависимость в файл build.gradle.kts:
     *
     * `dependencies {
     *     testImplementation("org.junit.jupiter:junit-jupiter:5.10.0")
     * }`
     *
     * Кроме того, чтобы правильно использовать Gradle с JUnit 5, добавьте приведённый ниже код в верхний уровень файла build.gradle.kts:
     *
     * `tasks.test {
     *     useJUnitPlatform()
     * }`
     *
     * Это говорит Gradle использовать JUnitPlatform для запуска тестов, иначе Gradle не сможет увидеть ваши тесты и запустить их.
     *
     * Теперь вы готовы написать свой первый тест. Создайте класс в папке src/test/kotlin вашего проекта и назовите его CalculatorTest.
     *
     * Имена тестовых классов начинаются с имени класса или объекта, который они тестируют, и заканчиваются словом «Test».
     *
     * В качестве альтернативы, если вы используете IntelliJ IDEA, щелкните правой кнопкой мыши имя класса или объекта и выберите «Generate» (Alt+Insert), а затем Test... в раскрывающемся меню. Появится всплывающее окно. Оставьте значения по умолчанию и нажмите ОК. Затем среда IDE создаст для вас тестовый класс.
     *
     * Внутри класса добавьте новый метод testAddition и аннотируйте его @Test из `org.junit.jupiter.api.Test`. Эта аннотация сообщает платформе JUnit, что метод является методом модульного тестирования.
     *
     * Обычное соглашение об именах заключается в использовании формата FunctionName_TestCondition_ExpectedOutcome. Это помогает четко указать цель теста, включая тестируемый метод, входные данные или условия, с которыми вызывается метод, и ожидаемый результат. Например, add_addingOneAndTwo_shouldReturnThree. Другое распространенное соглашение об именах — это When_TestCondition_Expect_ExpectedOutcome, которое будет использоваться в этом разделе. Обратите внимание, что существуют другие соглашения об именах для тестовых функций. В kotlin мы можем писать имена функций с пробелами, как в примере выше, используя ``. Это улучшает читабельность и позволяет называть тесты более человечно. Важно, чтобы имена были одинаковыми во всем проекте, чтобы тестовые примеры было легко понять и идентифицировать.
     *
     * @Test
     * fun `when adding 1 and 2 expect 3`() {
     *     val result = Calculator.add(1, 2)
     *
     *     assertEquals(3, result)
     * }
     *
     * Стоит отметить, что вы также можете использовать аннотацию @DisplayName("Описание теста") для описания ваших тестов, сохраняя при этом простое имя функции. Это редко используется, но может быть полезно в определенных случаях.
     *
     * Тест выдаёт AssertionFailedError если assertEquals не соответствует ожиданиям
     *
     * Некоторые методы утверждений для сравнения:
     * - assertEquals - проверяет, равны ли аргументы
     * - assertTrue - проверяет, является ли значение true
     * - assertFalse - проверяет, является ли значение false
     * - assertNull - проверяет, является ли значение null
     * - assertNotNull - проверяет, является ли значение не null
     * - assertThrows - проверяет, вызывает ли аргумент определённое исключение
     *
     * Добавьте следующие строки в файл build.gradle.kts, чтобы увидеть более подробные выходные данные для выполненных тестов:
     *
     * testLogging {
     *     events("passed", "skipped", "failed")
     * }
     *
     * Запуск через терминал: ./gradlew test
     */

    /**
     * MockK — мощная библиотека для создания моков, разработанная для языка Kotlin. Он предлагает простой и интуитивно понятный способ создания фиктивных объектов и управления ими в целях тестирования. С помощью MockK разработчики могут создавать тестовых двойников, определять их поведение и проверять взаимодействие с ними. MockK также поддерживает новейшие функции Kotlin, включая сопрограммы и функции расширения.
     *
     * Mock — это метод, используемый для имитации внешних зависимостей и создания изолированных тестов.
     *
     * Другие популярные библиотеки для имитации, такие как Mockito и JMockit, требуют больше шаблонного кода и могут быть более сложными в настройке.
     *
     * MockK предлагает более лаконичный и естественный API, который легче изучить и использовать.
     *
     * Добавление зависимости:
     * testImplementation("io.mockk:mockk:1.13.5")
     *
     * Далее вам нужно импортировать библиотеку MockK в свой тестовый класс:
     * import io.mockk.*
     *
     * Прежде чем определить поведение фиктивного объекта, мы должны сначала создать его. В MockK это делается с помощью функции mockk(). Например, чтобы создать фиктивный объект класса Calculator, мы можем использовать следующий код:
     *
     * `val calculatorMock = mockk<Calculator>()`
     *
     * Создав фиктивный объект, мы можем определить его поведение с помощью функции `every {}`. Эта функция позволяет указать возвращаемое значение метода или свойства фиктивного объекта.
     *
     * Например, чтобы заглушить метод add() нашего фиктивного объекта Calculator, чтобы он всегда возвращал 5, мы можем использовать следующий код:
     *
     * `every { calculatorMock.add(any(), any()) } returns 5`
     *
     * Здесь мы используем функцию any(), чтобы указать, что метод add() может принимать любые два аргумента. Затем мы используем ключевое слово return, чтобы указать, что метод всегда должен возвращать 5.
     *
     * Помимо подавления поведения фиктивного объекта, мы также можем проверить, правильно ли он использовался. Это делается с помощью функции `verify {}`.
     *
     * Например, чтобы убедиться, что метод add() нашего фиктивного объекта Calculator был вызван с аргументами 2 и 3, мы можем использовать следующий код:
     *
     * `verify { calculatorMock.add(2, 3) }`
     *
     * В некоторых случаях нам может понадобиться имитировать метод void, который не возвращает значение. Это можно сделать с помощью синтаксиса just runs.
     *
     * Например, чтобы имитировать метод log() класса Logger, который не возвращает значение, мы можем использовать следующий код:
     *
     * `val loggerMock = mockk<Logger>()
     *
     * justRun { loggerMock.log(any()) }`
     *
     * Здесь мы используем функцию justRun(), чтобы указать, что метод log() не должен возвращать значение.
     *
     * В некоторых случаях нам может понадобиться имитировать final class, что невозможно с некоторыми другими фреймворками. MockK предлагает решение этой проблемы, используя генерацию байт-кода для создания прокси для final class.
     *
     * Например, чтобы смоделировать final class MyFinalClass, мы можем использовать следующий код:
     *
     * `mockkObject(MyFinalClass::class)`
     *
     * Spying
     *
     * Платформа MockK в Kotlin предоставляет функцию, называемую «шпионаж», которая позволяет разработчикам создавать объект-шпион и может отслеживать взаимодействие между объектом и методами. Шпионский объект может быть создан с помощью функции spyk(), она принимает экземпляр объекта, за которым нужно следить.
     *
     * Использование объекта-шпиона особенно полезно, когда мы хотим протестировать метод, который зависит от других методов. Отслеживая зависимости, мы можем убедиться, что тестируемый метод вызывает их правильно. Кроме того, мы можем использовать шпионский объект для проверки того, что определенные методы вызывались определенное количество раз, с определенными аргументами или в определенном порядке.
     *
     * Object mocking
     *
     * Во фреймворке MockK для Kotlin функция mockkObject используется для имитации всего объекта. Это означает, что все функции и свойства объекта будут заменены фиктивными реализациями.
     *
     * Следует отметить, что при использовании mockkObject все функции и свойства объекта заменяются фиктивными реализациями. Это означает, что если у вас есть другой код, который использует настоящий MyObject (например, если MyObject является синглтоном, используемым во всей вашей кодовой базе), этот код также будет затронут макетом. Если вы хотите имитировать только определённую функцию или свойство объекта, вместо этого вы должны использовать функцию mockk.
     *
     * Using argument matchers in MockK
     *
     * Сопоставители аргументов можно использовать для сопоставления конкретных значений, любых значений, нулевых значений, диапазонов значений и коллекций. В MockK сопоставители аргументов создаются с использованием набора функций, специально разработанных для сопоставления различных типов значений.
     *
     * 1) Соответствие конкретным значениям
     *
     * MockK предоставляет несколько функций для сопоставления определённых значений:
     * - eq() используется для сопоставления точного значения
     * - match() используется для сопоставления значения с помощью пользовательской функции сопоставления.
     *
     * Например, чтобы сопоставить строку со значением «foo», мы можем использовать функцию eq() следующим образом:
     *
     * `every { myMockObject.myMethod(eq("foo")) } returns 42`
     *
     * 2) Соответствие любому значению
     *
     * Чтобы сопоставить любое значение определённого типа, мы можем использовать функцию any().
     *
     * Например, чтобы сопоставить любое строковое значение, мы можем использовать функцию any() следующим образом:
     *
     * `every { myMockObject.myMethod(any()) } returns 42`
     *
     * 3) Соответствие нулевым значениям
     *
     * Чтобы сопоставить нулевые значения, мы можем использовать функцию isNull().
     *
     * Например, чтобы сопоставить значение нулевой строки, мы можем использовать функцию isNull() следующим образом:
     *
     * `every { myMockObject.myMethod(isNull<String>()) } returns 42`
     *
     * 4) Сопоставление диапазонов значений
     *
     * MockK предоставляет несколько функций для сопоставления диапазонов значений, включая less(), lessEq(), Greater(), GreatEq() и Range().
     *
     * Например, чтобы сопоставить целочисленное значение от 10 до 20, мы можем использовать функцию range() следующим образом:
     *
     * `every { myMockObject.myMethod(range(10, 20)) } returns 42`
     *
     * 5) Соответствующие коллекции
     *
     * Для сопоставления коллекций мы можем использовать функцию match() с пользовательской функцией сопоставления, которая проверяет содержимое коллекции.
     *
     * Например, чтобы сопоставить список строк, содержащих значения «foo» и «bar», мы можем использовать функцию match() следующим образом:
     *
     * `every { myMockObject.myMethod(match { it.contains("foo") && it.contains("bar") }) } returns 42`
     *
     * MockK предоставляет несколько часто используемых средств сопоставления аргументов, которые можно использовать в модульных тестах Kotlin.
     *
     * К ним относятся:
     *
     * - eq(). Функция eq() используется для сопоставления точного значения. Его можно использовать для сопоставления любого типа значения, включая примитивные типы и объекты.
     *
     * - any(). Функция any() используется для сопоставления любого значения определённого типа. Его можно использовать для сопоставления любого типа значения, включая примитивные типы и объекты.
     *
     * - captor(). Функция captor() используется для захвата значения аргумента, который передаётся фиктивному методу. Это может быть полезно для тестирования методов с побочными эффектами или для проверки того, что определённые значения были переданы методу.
     *
     * - slot(). Функция slot() похожа на функцию captor(), но она захватывает значение аргумента в объект слота. Это может быть полезно для тестирования методов, возвращающих значения, или для проверки того, что определённые значения были переданы методу.
     *
     * - argThat(). Функция argThat() используется для сопоставления аргумента с использованием пользовательской функции сопоставления. Это может быть полезно для тестирования методов со сложными требованиями к аргументам или для проверки передачи определённых значений.
     */
}

/**
 * Простой калькулятор, который выполняет базовые вычисления с целыми числами и проверяет чётные числа
 */
object Calculator {
    fun add(a: Int, b: Int): Int = a + b

    fun subtract(a: Int, b: Int): Int = a - b

    fun multiply(a: Int, b: Int): Int = a * b

    fun divide(a: Int, b: Int): Int {
        require(b != 0) { "Divisor cannot be zero!" }

        return a / b
    }

    fun isEven(a: Int): Boolean = a % 2 == 0
}

interface CalculatorInterface {
    fun add(x: Int, y: Int): Int
    fun subtract(x: Int, y: Int): Int
}

class CalculatorService(private val calculator: CalculatorInterface) {
    fun addAndSubtract(x: Int, y: Int): Int {
        val sum = calculator.add(x, y)
        val difference = calculator.subtract(x, y)

        return sum - difference
    }
}

class Example {
    fun method1(): String = "method1"
    fun method2(): String = "method2"
}

object MyTestObject {
    fun myFunction() {
        // ...
    }

    val myProperty: String = "Hello, world!"
}

/**
 * Все сложные приложения интегрируются с какими-то другими частями, такими как базы данных, файловые системы и т. д. Таким образом, получается, что разработчикам также нужно тестировать, как все эти части будут работать вместе. Для этого и нужны интеграционные тесты.
 *
 * Они берут уже протестированные модули в качестве входных данных, группируют их в более крупные наборы, запускают тесты, определенные в плане тестирования для этих наборов, и представляют их в качестве выходных данных и входных данных для последующего тестирования системы. Цель — проверить интеграцию приложения со всеми внешними компонентами.
 *
 * Так что при таком тестировании нужно запускать не только само приложение, но и компоненты, которые будут интегрироваться. Например, если вы хотите проверить интеграцию с базой данных, вам следует запустить базу данных при выполнении тестов.
 */
fun integrationTesting() {
    println("--- Integration testing ---")
}

/**
 * После интеграционных тестов можно проверить всю систему от начала до конца. Это называется сквозным тестированием.
 *
 * Сквозное тестирование — это методология тестирования программного обеспечения, позволяющая полностью протестировать поток приложений. Целью сквозного тестирования является моделирование реального пользовательского сценария и проверка тестируемой системы, а также ее компонентов на интеграцию и целостность данных.
 *
 * Это выполняется в реальных сценариях, таких как связь приложения с оборудованием, сетью, базой данных и другими приложениями.
 *
 * Сквозные тесты очень полезны, но их выполнение дорого обходится, и их сложно поддерживать, когда они автоматизированы. Рекомендуется иметь несколько ключевых сквозных тестов и больше полагаться на типы тестирования более низкого уровня (модульные и интеграционные тесты), чтобы иметь возможность быстро выявлять новые ошибки.
 */
fun endToEndTesting() {
    println("--- End-to-end testing ---")
}

/**
 * Тестирование пользовательского интерфейса означает тестирование пользовательского интерфейса. Идея в том, что QA-инженеры имитируют действия пользователя, т.е. клики по кнопкам и ссылкам и другие действия подобного типа. Суть в том, чтобы проверить взаимодействие между компонентами. Если вы, скажем, сделали новый сайт, то во время UI-тестирования вы проверите, например, как работает поиск, могут ли пользователи заходить и выходить, как открываются разделы и так далее.
 *
 * Тестирование пользовательского интерфейса может выполняться не только разработчиками, но и пользователями. Этот тип функционального тестирования называется бета-тестированием.
 *
 * Бета-тестирование или приемочное тестирование проводится в самом конце, когда сырая или бета-версия продукта готова. Бета-тестирование — это интенсивное использование почти готовой версии продукта с целью выявления как можно большего количества ошибок до того, как продукт будет окончательно выпущен на рынок. Он требует не разработчиков, как во всех предыдущих методах тестирования, а добровольцев, которые какое-то время будут пользоваться продуктом и указывать на его недостатки.
 */
fun uiTesting() {
    println("--- UI testing ---")
}

/**
 * Kotlin изначально был разработан со встроенной поддержкой многопоточности. Потоки поддерживаются на уровне JVM, уровне языка (специальные ключевые слова) и уровне стандартной библиотеки.
 *
 * В каждой программе Kotlin есть хотя бы один поток, который называется основным; он создаётся автоматически процессом JVM для выполнения операторов внутри функции main().
 *
 * В любой программе на Kotlin есть и другие потоки по умолчанию (например, отдельный поток для сборщика мусора).
 *
 * Поток — это последовательность инструкций, которые программа может выполнить во время своего запуска. Каждый поток представлен объектом — экземпляром класса java.lang.Thread (или его подкласса).
 *
 * Класс Thread имеет множество конструкторов. Полный список вы можете найти здесь: https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#constructor_summary
 *
 * Разница между режимом демона и режимом без демона заключается в том, что JVM не будет завершать работающую программу, пока ещё остаются потоки, не являющиеся демонами, в то время как потоки демона не препятствуют завершению работы JVM. Потоки-демоны обычно выполняют некоторую фоновую работу.
 */
fun main() {
    /**
     * Класс Thread имеет статический метод с именем currentThread для получения ссылки на выполняющийся в данный момент объект потока:
     */
    val thread: Thread = Thread.currentThread()

    /**
     * Класс Thread хранит базовую информацию о потоке: его имя, идентификатор (длинный), приоритет и некоторые другие характеристики, которые можно получить с помощью его функций.
     */
    // Возвращает имя потока
    println("Name: ${thread.name}") // main

    // Возвращает уникальный идентификатор потока
    println("ID: ${thread.threadId()}") // 1

    // Сообщает нам, был ли поток запущен и ещё не умер
    println("Alive: ${thread.isAlive}") // true

    // Возвращает приоритет данного потока.
    // Каждый поток имеет приоритет, определяющий порядок выполнения: потоки с более высоким приоритетом выполняются раньше потоков с более низким приоритетом
    println("Priority: ${thread.priority}") // 5

    // Проверяет, является ли поток демоном.
    // Поток демона (в терминологии UNIX) — это поток с низким приоритетом, который работает в фоновом режиме для выполнения таких задач, как сбор мусора и т.д.
    // JVM не ждёт остановки потоков демона перед выходом, в то время как она делает это для потоков, не являющихся демонами.
    println("Daemon: ${thread.isDaemon}") // false

    // Каждую характеристику можно изменить, задав новое значение.
    thread.name = "my-thread"

    println("New name: ${thread.name}") // New name: my-thread

    customThreads()

    simpleMultiThreadedProgram()
}

/**
 * Основной поток — это отправная точка, из которой вы можете создавать новые потоки для выполнения своих задач.
 *
 * Для этого вам нужно создать свои собственные потоки, написать код, который будет выполняться в отдельном потоке, а затем запустить его.
 *
 * Два основных способа создания нового потока, выполняющего нужную вам задачу, следующие:
 *
 * - расширение класса Thread и переопределение его метода запуска;
 *
 * - реализация интерфейса Runnable и передача реализации конструктору класса Thread.
 *
 * В обоих случаях вам следует переопределить метод run, который является обычным методом и содержит код для выполнения задачи.
 *
 * Класс Thread имеет метод start(), который используется для запуска потока. В какой-то момент после вызова этого метода метод run будет вызван автоматически, но это произойдёт не сразу.
 *
 * Не путайте методы run и start. Вы должны вызвать start, если хотите выполнить свой код внутри другого потока. Если вы вызываете run напрямую, код будет выполнен в том же потоке.
 *
 * Если вы попытаетесь запустить поток более одного раза, start выдаст исключение IllegalThreadStateException.
 *
 * Не полагайтесь на порядок выполнения операторов между разными потоками, если вы не приняли специальные меры.
 */
fun customThreads() {
    /**
     * В приведённом ниже коде приведён пример расширения класса Thread и переопределения его метода запуска.
     *
     * Если вы расширите класс Thread, вы сможете принимать поля и методы базового класса, но не сможете расширять другими классами, поскольку в Котлине нет множественного наследования классов.
     */
    class HelloThread : Thread() {
        override fun run() {
            val helloMsg = "Hello, i'm $name"

            println(helloMsg)
        }
    }

    val thread1 = HelloThread() // a subclass of Thread

    // Через время запустится run и println()
    // Hello, i'm Thread-0
    thread1.start()

    /**
     * Следующий код показывает, как реализовать интерфейс Runnable и передать реализацию конструктору класса Thread:
     */
    class HelloRunnable : Runnable {
        override fun run() {
            val threadName = Thread.currentThread().name
            val helloMsg = "Hello, i'm $threadName"

            println(helloMsg)
        }
    }

    val thread2 = Thread(HelloRunnable()) // passing runnable

    // Через время запустится run и println()
    // Hello, i'm Thread-1
    thread2.start()

    /**
     * А вот еще один способ указать имя вашего потока, передав его конструктору:
     */
    val thread3 = Thread(HelloRunnable(), "my-thread")

    // Через время запустится run и println()
    // Hello, i'm my-thread
    thread3.start()

    // Порядок отображения сообщений может быть разным
    println("Finished")
}

/**
 * Простая многопоточная программа с двумя потоками. Первый поток считывает числа из стандартного ввода и выводит их квадраты. В то же время основной поток время от времени выводит сообщения на стандартный вывод. Оба потока работают одновременно.
 */
fun simpleMultiThreadedProgram() {
    /**
     * Поток, который циклически считывает числа и возводит их в квадрат. У него есть оператор прерывания, позволяющий остановить цикл, если заданное число равно 0.
     */
    class SquareWorkerThread(name: String) : Thread(name) {
        override fun run() {
            while (true) {
                val number: Int = readln().toInt()

                if (number == 0) {
                    break
                }

                println(number * number)
            }

            println("$name's finished")
        }
    }

    /**
     * Запускает объект класса SquareWorkerThread, который записывает сообщения в стандартный вывод из основного потока.
     */
    val workerThread = SquareWorkerThread("square-worker")

    workerThread.start() // start a worker (not run!)

    // Hello from the main!
    // Hello from the main!
    // Hello from the main!
    // Hello from the main!
    // Hello from the main!
    // Hello from the main!
    // 2 // input
    // 4 // result
    // 3 // input
    // 9 // result
    // 5 // input
    // 25 // result
    // 0 // input
    // square-worker's finished
    for (i: Long in 0 ..< 5_555_555_543L) {
        if (i % 1_000_000_000 == 0L) {
            println("Hello from the main!")
        }
    }
}

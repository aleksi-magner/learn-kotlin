/**
 * Отладка — это процесс поиска и исправления ошибок в программе.
 *
 * Некоторые ошибки, например те, которые мешают компиляции программы, можно легко исправить, поскольку компилятор или IDE могут сказать вам, что не так.
 *
 * Другие ошибки сложнее и могут потребовать от вас больших усилий для их обнаружения.
 *
 * Логирование (Logging), отладка через «println»
 *
 * Самый простой метод — вставка операторов println для отслеживания значений и порядка выполнения вашей программы. При выполнении они сообщат вам о том, что происходит «под капотом» во время выполнения.
 *
 * Не следует использовать этот метод в реальных проектах, поскольку современные отладчики могут делать то же самое гораздо более удобным способом и потому что вы не сможете делать это везде. Например, если вы хотите получить информацию из кода какой-либо библиотеки, это будет проблемой, поскольку вы не сможете изменять скомпилированный код.
 *
 * Утверждения (Assertions)
 *
 * Утверждение — это механизм, который отслеживает состояние программы, но, в отличие от дополнительных операторов печати, он завершает программу безотказным способом (fail-fast), если что-то идёт не так.
 *
 * Fail-fast — это подход, при котором ошибки, которые в противном случае могли бы быть нефатальными, вызывают немедленный сбой, что делает их видимыми.
 *
 * Вы можете задаться вопросом, почему может потребоваться сбой производственного кода. Это потому, что потерпеть неудачу немедленно гораздо безопаснее, чем совершить неправильный поступок.
 *
 * Вам следует использовать require при проверке аргумента, переданного функции, и check при проверке состояния объекта
 *
 * Инварианты — это ограничения, которые должны соблюдаться для правильной работы программы.
 *
 * В приведенном ниже коде положительный возраст является примером инварианта. Использование отрицательного возраста порождает проблему.
 *
 * Именно для обеспечения соблюдения инвариантов нам нужны утверждения.
 *
 * Мы также можем использовать утверждения для проверки предусловий и постусловий метода, то есть условий, которые должны быть выполнены до или после вызова метода.
 *
 * Подключение отладчика (Attaching a debugger)
 *
 * Отладчик — это инструмент, который мешает нормальному выполнению программы, позволяя вам получать информацию о времени выполнения и тестировать различные сценарии для диагностики ошибок.
 *
 * Это наиболее популярное использование отладчиков.
 *
 * Однако, когда вы приобретете больше опыта работы с ними, вы увидите, что они могут быть полезны в различных ситуациях, не обязательно связанных с ошибками.
 *
 * Современные отладчики предоставляют широкий спектр инструментов, которые можно использовать для диагностики самых сложных сбоев.
 */
fun main() {
    /**
     * Этот код создаёт объект Cat. Все было бы хорошо, если бы не бессмысленное отрицательное значение возраста.
     *
     * Естественно, в более сложной программе это может привести к различным ошибкам. Такой объект можно долго обходить стороной, прежде чем мы увидим проблему, а когда возникает проблема, не всегда очевидно, в чем её причина.
     *
     * Чтобы этого не произошло, мы можем проверить, чтобы параметр «возраст» был положительным, а «имя» не было пустым:
     *
     * Первый параметр — это логическое выражение, которое следует проверить, и когда оно принимает значение false, выдаётся исключение.
     *
     * Второй параметр — это функция, которая генерирует сообщение, описывающее эту ошибку.
     *
     * Вам следует использовать require при проверке аргумента, переданного функции, и check при проверке состояния объекта, как в этом случае.
     */
    class Cat(val name: String, val age: Int) {
        val enoughCat: Boolean = name == "Many"

        init {
            check(!enoughCat) { "You cannot add a new cat" } // IllegalStateException
            require(age >= 0) { "Invalid age: $age" } // IllegalArgumentException
        }
    }

    val cat1 = Cat("Tom", 3)

    println("Cat ${cat1.name}: ${cat1.age}") // Cat Tom: 3

    // Exception in thread "main" java.lang.IllegalArgumentException: Invalid age: -1
    // 	at DebuggingKt$main$Cat.<init>(Debugging.kt:49)
    // 	at DebuggingKt.main(Debugging.kt:61)
    // 	at DebuggingKt.main(Debugging.kt)
    // val cat2 = Cat("Casper", -1)

    // Exception in thread "main" java.lang.IllegalStateException: You cannot add a new cat
    // 	at DebuggingKt$main$Cat.<init>(Debugging.kt:48)
    // 	at DebuggingKt.main(Debugging.kt:63)
    // 	at DebuggingKt.main(Debugging.kt)
    // val cat3 = Cat("Many", 0)

    debugging()
}

/**
 * Отладчик — это программа для поиска ошибок или багов в коде, автоматизирующая процесс отладки. Это позволяет программисту наблюдать за выполнением программы для определения точного места ошибки.
 *
 * Основной принцип отладки заключается в том, что она может заморозить выполнение программы, т.е. приостановить его. Таким образом, можно просмотреть программу в замороженном состоянии.
 *
 * Существует два способа приостановить работающий код при отладке:
 *
 * - установите точки останова в коде, который вы хотите проверить, и подождите, пока не будет достигнута одна из них.
 *
 * - прервать выполнение программы нажатием горячих клавиш или кнопки остановки, если вы работаете в графическом интерфейсе. Отладчик завершит оператор, выполняющийся в данный момент, а затем остановит программу.
 *
 * Точка останова означает намеренное прерывание выполнения программы. Он задается в том месте программы, в котором вы хотите проверить ее работу. После того как программа достигнет этой точки, она завершится. Тогда у вас будет возможность изучить состояние программы, например, логи, состояние памяти, регистры процессора, стек и так далее.
 *
 * В отличие от полной остановки, с помощью останова в отладчике программу можно завершить или продолжить с того же места, где произошел останов.
 *
 * Также стоит отметить, что для строки кода с точкой останова результат работы этой строки пока неизвестен. Таким образом, после того, как код прерывается в точке останова, вы можете видеть только результаты всех предыдущих строк до точки останова.
 */
fun debugging() {
    println("--- If expressions ---")

    whateverIF()

    println("--- Loops ---")

    whateverLoop()

    println("--- Tasks ---")

    fibonacci()
    bitwiseAndIntegers()
    divisorsFinding()
    primesAndHowFindThem()
}

fun whateverIF() {
    var greeting = "Hello world"

    // Если бы условие не выполнилось, программа не остановилась бы в отмеченной точке
    if (greeting.contains("e")) {
        greeting += "!" // breakpoint,  greeting == "Hello world"

        println(greeting)
    }

    println("Shutting down")
}

/**
 * Чтобы не перебирать весь цикл, можно добавить дополнительное условие для останова.
 *
 * Щелкните правой кнопкой мыши точку останова и укажите условие: c == 'H'.
 *
 * Условие — это просто логическое выражение, которое должно иметь значение true, чтобы программа остановилась на этой точке останова.
 *
 * Обратите внимание, что программа оценивает условие в контексте кода, в котором установлена точка останова.
 *
 * Например, условие `c == 'H'` не будет работать для точки останова вне цикла, поскольку переменная `c` там не видна.
 */
fun whateverLoop() {
    val rangeStart = 'C'
    val rangeEnd = 'Y'
    val findLetter = 'Q'

    for (c in rangeStart..rangeEnd) {
        if (c == findLetter) { // breakpoint, c == 'H'
            println("Character $findLetter is within range $rangeStart–$rangeEnd")

            return
        }
    }

    println("Character $findLetter is not within range $rangeStart–$rangeEnd")
}

/**
 * Каково значение переменной current в конце 20-й итерации (i == 19)?
 */
fun fibonacci() {
    var prev = 0
    var current = 1

    for (i in 0..24) {
        val swap = prev

        prev = current

        current += swap

        println(current) // breakpoint, 10946
    }
}

/**
 * Ниже вы можете увидеть код, использующий побитовые операции.
 *
 * По умолчанию отладчик отображает переменные как целые числа. Однако в этом случае гораздо удобнее видеть их в бинарном формате.
 *
 * Для этого щелкните правой кнопкой мыши переменную на панели «Переменные» (Variables) отладчика и выберите «Просмотреть как» > «Двоичный» (View as > Binary) (чтобы вернуться к представлению по умолчанию, выберите «Просмотр как» > «Примитивный» (View as > Primitive)).
 *
 * В качестве ответа введите двоичное представление переменной result, которая появится в отладчике с префиксом 0b.
 */
fun bitwiseAndIntegers() {
    var number1 = 38
    var number2 = 54

    number1 = number1 shl 2
    number2 = number2 shr 1

    var result = number2 xor number1 // 0b10000011
} // breakpoint, 0b10000011

/**
 * Используя данный код и отладчик, найдите наименьший делитель числа 5977 (кроме 1, конечно).
 */
fun isPrime(number: Int): Boolean {
    for (i in 2..(number / 2)) {
        if (number % i != 0) {
            continue
        } else {
            return false // breakpoint, 43
        }
    }

    return true
}

fun divisorsFinding() {
    val result = isPrime(5977) // 43
}

/**
 * Используя приведенный ниже код и отладчик, найдите наибольшее простое число, меньшее 459.
 */
fun primesAndHowFindThem() {
    var greatestPrimeInRange = 2

    for (number in 2..1000) {
        if (isPrime(number) && number > greatestPrimeInRange) {
            greatestPrimeInRange = number // breakpoint, 457
        }
    }
}

import java.util.logging.Level
import java.util.logging.Logger

import java.util.logging.FileHandler
import java.util.logging.Handler
import java.util.logging.LogRecord
import java.util.logging.XMLFormatter

import java.util.logging.Filter

import org.slf4j.Logger as LogbackLogger
import org.slf4j.LoggerFactory

/**
 * Отладка — это процесс поиска и исправления ошибок в программе.
 *
 * Некоторые ошибки, например те, которые мешают компиляции программы, можно легко исправить, поскольку компилятор или IDE могут сказать вам, что не так.
 *
 * Другие ошибки сложнее и могут потребовать от вас больших усилий для их обнаружения.
 *
 * Логирование (Logging), отладка через «println»
 *
 * Самый простой метод — вставка операторов println для отслеживания значений и порядка выполнения вашей программы. При выполнении они сообщат вам о том, что происходит «под капотом» во время выполнения.
 *
 * Не следует использовать этот метод в реальных проектах, поскольку современные отладчики могут делать то же самое гораздо более удобным способом и потому что вы не сможете делать это везде. Например, если вы хотите получить информацию из кода какой-либо библиотеки, это будет проблемой, поскольку вы не сможете изменять скомпилированный код.
 *
 * Утверждения (Assertions)
 *
 * Утверждение — это механизм, который отслеживает состояние программы, но, в отличие от дополнительных операторов печати, он завершает программу безотказным способом (fail-fast), если что-то идёт не так.
 *
 * Fail-fast — это подход, при котором ошибки, которые в противном случае могли бы быть нефатальными, вызывают немедленный сбой, что делает их видимыми.
 *
 * Вы можете задаться вопросом, почему может потребоваться сбой производственного кода. Это потому, что потерпеть неудачу немедленно гораздо безопаснее, чем совершить неправильный поступок.
 *
 * Вам следует использовать require при проверке аргумента, переданного функции, и check при проверке состояния объекта
 *
 * Инварианты — это ограничения, которые должны соблюдаться для правильной работы программы.
 *
 * В приведенном ниже коде положительный возраст является примером инварианта. Использование отрицательного возраста порождает проблему.
 *
 * Именно для обеспечения соблюдения инвариантов нам нужны утверждения.
 *
 * Мы также можем использовать утверждения для проверки предусловий и постусловий метода, то есть условий, которые должны быть выполнены до или после вызова метода.
 *
 * Подключение отладчика (Attaching a debugger)
 *
 * Отладчик — это инструмент, который мешает нормальному выполнению программы, позволяя вам получать информацию о времени выполнения и тестировать различные сценарии для диагностики ошибок.
 *
 * Это наиболее популярное использование отладчиков.
 *
 * Однако, когда вы приобретете больше опыта работы с ними, вы увидите, что они могут быть полезны в различных ситуациях, не обязательно связанных с ошибками.
 *
 * Современные отладчики предоставляют широкий спектр инструментов, которые можно использовать для диагностики самых сложных сбоев.
 */
fun main() {
    /**
     * Этот код создаёт объект Cat. Все было бы хорошо, если бы не бессмысленное отрицательное значение возраста.
     *
     * Естественно, в более сложной программе это может привести к различным ошибкам. Такой объект можно долго обходить стороной, прежде чем мы увидим проблему, а когда возникает проблема, не всегда очевидно, в чем её причина.
     *
     * Чтобы этого не произошло, мы можем проверить, чтобы параметр «возраст» был положительным, а «имя» не было пустым:
     *
     * Первый параметр — это логическое выражение, которое следует проверить, и когда оно принимает значение false, выдаётся исключение.
     *
     * Второй параметр — это функция, которая генерирует сообщение, описывающее эту ошибку.
     *
     * Вам следует использовать require при проверке аргумента, переданного функции, и check при проверке состояния объекта, как в этом случае.
     */
    class Cat(val name: String, val age: Int) {
        val enoughCat: Boolean = name == "Many"

        init {
            check(!enoughCat) { "You cannot add a new cat" } // IllegalStateException
            require(age >= 0) { "Invalid age: $age" } // IllegalArgumentException
        }
    }

    val cat1 = Cat("Tom", 3)

    println("Cat ${cat1.name}: ${cat1.age}") // Cat Tom: 3

    // Exception in thread "main" java.lang.IllegalArgumentException: Invalid age: -1
    // 	at DebuggingKt$main$Cat.<init>(Debugging.kt:49)
    // 	at DebuggingKt.main(Debugging.kt:61)
    // 	at DebuggingKt.main(Debugging.kt)
    // val cat2 = Cat("Casper", -1)

    // Exception in thread "main" java.lang.IllegalStateException: You cannot add a new cat
    // 	at DebuggingKt$main$Cat.<init>(Debugging.kt:48)
    // 	at DebuggingKt.main(Debugging.kt:63)
    // 	at DebuggingKt.main(Debugging.kt)
    // val cat3 = Cat("Many", 0)

    debugging()
    logging()
    logback()
}

/**
 * Отладчик — это программа для поиска ошибок или багов в коде, автоматизирующая процесс отладки. Это позволяет программисту наблюдать за выполнением программы для определения точного места ошибки.
 *
 * Основной принцип отладки заключается в том, что она может заморозить выполнение программы, т.е. приостановить его. Таким образом, можно просмотреть программу в замороженном состоянии.
 *
 * Существует два способа приостановить работающий код при отладке:
 *
 * - установите точки останова в коде, который вы хотите проверить, и подождите, пока не будет достигнута одна из них.
 *
 * - прервать выполнение программы нажатием горячих клавиш или кнопки остановки, если вы работаете в графическом интерфейсе. Отладчик завершит оператор, выполняющийся в данный момент, а затем остановит программу.
 *
 * Точка останова означает намеренное прерывание выполнения программы. Он задается в том месте программы, в котором вы хотите проверить ее работу. После того как программа достигнет этой точки, она завершится. Тогда у вас будет возможность изучить состояние программы, например, логи, состояние памяти, регистры процессора, стек и так далее.
 *
 * В отличие от полной остановки, с помощью останова в отладчике программу можно завершить или продолжить с того же места, где произошел останов.
 *
 * Также стоит отметить, что для строки кода с точкой останова результат работы этой строки пока неизвестен. Таким образом, после того, как код прерывается в точке останова, вы можете видеть только результаты всех предыдущих строк до точки останова.
 */
fun debugging() {
    println("--- If expressions ---")

    whateverIF()

    println("--- Loops ---")

    whateverLoop()

    println("--- Tasks ---")

    fibonacci()
    bitwiseAndIntegers()
    divisorsFinding()
    primesAndHowFindThem()

    val password = modifyString("my password is 12345")

    println(password)

    fibonacciSum()
}

fun whateverIF() {
    var greeting = "Hello world"

    // Если бы условие не выполнилось, программа не остановилась бы в отмеченной точке
    if (greeting.contains("e")) {
        greeting += "!" // breakpoint,  greeting == "Hello world"

        println(greeting)
    }

    println("Shutting down")
}

/**
 * Чтобы не перебирать весь цикл, можно добавить дополнительное условие для останова.
 *
 * Щелкните правой кнопкой мыши точку останова и укажите условие: c == 'H'.
 *
 * Условие — это просто логическое выражение, которое должно иметь значение true, чтобы программа остановилась на этой точке останова.
 *
 * Обратите внимание, что программа оценивает условие в контексте кода, в котором установлена точка останова.
 *
 * Например, условие `c == 'H'` не будет работать для точки останова вне цикла, поскольку переменная `c` там не видна.
 */
fun whateverLoop() {
    val rangeStart = 'C'
    val rangeEnd = 'Y'
    val findLetter = 'Q'

    for (c in rangeStart..rangeEnd) {
        if (c == findLetter) { // breakpoint, c == 'H'
            println("Character $findLetter is within range $rangeStart–$rangeEnd")

            return
        }
    }

    println("Character $findLetter is not within range $rangeStart–$rangeEnd")
}

/**
 * Каково значение переменной current в конце 20-й итерации (i == 19)?
 */
fun fibonacci() {
    var prev = 0
    var current = 1

    for (i in 0..24) {
        val swap = prev

        prev = current

        current += swap

        println(current) // breakpoint, 10946
    }
}

/**
 * Ниже вы можете увидеть код, использующий побитовые операции.
 *
 * По умолчанию отладчик отображает переменные как целые числа. Однако в этом случае гораздо удобнее видеть их в бинарном формате.
 *
 * Для этого щелкните правой кнопкой мыши переменную на панели «Переменные» (Variables) отладчика и выберите «Просмотреть как» > «Двоичный» (View as > Binary) (чтобы вернуться к представлению по умолчанию, выберите «Просмотр как» > «Примитивный» (View as > Primitive)).
 *
 * В качестве ответа введите двоичное представление переменной result, которая появится в отладчике с префиксом 0b.
 */
fun bitwiseAndIntegers() {
    var number1 = 38
    var number2 = 54

    number1 = number1 shl 2
    number2 = number2 shr 1

    var result = number2 xor number1 // 0b10000011
} // breakpoint, 0b10000011

/**
 * Используя данный код и отладчик, найдите наименьший делитель числа 5977 (кроме 1, конечно).
 */
fun isPrime(number: Int): Boolean {
    for (i in 2..(number / 2)) {
        if (number % i != 0) {
            continue
        } else {
            return false // breakpoint, 43
        }
    }

    return true
}

fun divisorsFinding() {
    val result = isPrime(5977) // 43
}

/**
 * Используя приведенный ниже код и отладчик, найдите наибольшее простое число, меньшее 459.
 */
fun primesAndHowFindThem() {
    var greatestPrimeInRange = 2

    for (number in 2..1000) {
        if (isPrime(number) && number > greatestPrimeInRange) {
            greatestPrimeInRange = number // breakpoint, 457
        }
    }
}

/**
 * С помощью отладчика узнайте значение переменной modifiedString непосредственно перед выполнением строки, отмеченной // breakpoint.
 */
fun modifyString(initialString: String): String{
    var modifiedString = initialString

    modifiedString = modifiedString.removeRange(2, 10)

    if (modifiedString.contains(" ")) {
        modifiedString += "ABC"
    }

    modifiedString = modifiedString.substringAfter(" ") + modifiedString.substringBefore(" ")

    if (modifiedString.contains("a")) {
        modifiedString.plus("1248")
    }

    modifiedString = modifiedString.replaceFirst(" ", "$")

    if (modifiedString.length < 15) {
        modifiedString = modifiedString.reversed()
    }

    modifiedString += "18B20" // breakpoint, dymCBA54321$si

    modifiedString = modifiedString.substringAfter("1") + modifiedString.substringBefore("5")

    modifiedString.dropLast(4)

    return  modifiedString
}

/**
 * Ниже приведен код, который вычисляет числа Фибоначчи и их сумму в бесконечном цикле. Используя отладчик, найдите значение fibonacciSum, когда переменная fibonacciCurrent впервые станет больше 1000 и будет добавлена к сумме.
 */
fun fibonacciSum() {
    var fibonacciPrevious = 1
    var fibonacciCurrent = 1
    var fibonacciSum = fibonacciPrevious + fibonacciCurrent

    while(true) { // breakpoint, fibonacciSum == 4180
        val tmp = fibonacciPrevious + fibonacciCurrent

        fibonacciPrevious = fibonacciCurrent
        fibonacciCurrent = tmp
        fibonacciSum += fibonacciCurrent
    }
}

object Main {
    @JvmStatic
    // Аргументы опциональны
    fun main(args: Array<String>) {
        val logger = Logger.getLogger(Main::class.java.name)

        logger.log(Level.WARNING, "Hello ${logger.name}") // WARNING: Hello Main
    }
}

class FilterExample : Filter {
    override fun isLoggable(record: LogRecord): Boolean {
        return record.level === Level.INFO
    }
}

/**
 * Логирование — это записи программного приложения, которые мы сохраняем в файл или отображаем в консоли.
 *
 * Эти записи могут описывать что угодно: событие в приложении, значение переменной, ошибку или исключение в приложении. Журналы в основном используются для целей отладки.
 *
 * Пакет java.util.logging отвечает за предоставление разработчикам возможностей ведения журналов в стандартном SDK Java.
 *
 * При работе с журналированием Java необходимо изучить несколько компонентов: класс Logger, класс FileHandler, класс ConsoleHandler, SimpleFormatter, XMLFormatter, Level, LogRecord и LogManager.
 *
 * Класс Logger — наиболее важный и фундаментальный компонент пакета ведения журналов.
 *
 * Стандартной практикой является создание экземпляра журнала для каждого класса.
 *
 * Класс Logger представляет несколько методов для печати сообщений журнала.
 *
 * Каждое сообщение журнала связано с определённым уровнем журнала. Java использует Info в качестве уровня журнала по умолчанию.
 *
 * В пакете журналирования Java имеется семь уровней журналирования. В списке ниже они показаны от самой высокой до самой низкой степени серьёзности.
 * Класс Logger содержит методы, для которых не требуется указывать уровень журнала в качестве атрибута.
 *
 *  Log level   | Value | Method
 * - SEVERE     | 1000  | severe()
 * - WARNING    | 900   | warning()
 * - INFO       | 800   | info()
 * - CONFIG     | 700   | config()
 * - FINE       | 500   | fine()
 * - FINER      | 400   | finer()
 * - FINEST     | 300   | finest()
 *
 *
 * Следующими важными компонентами пакета журналирования являются обработчики (handlers) и средства форматирования (formatters), которые часто работают вместе.
 *
 * Обработчики несут ответственность за отправку реальных журналов во внешний мир.
 *
 * В пакете java.util.logging есть абстрактный класс Handler.
 *
 * Он расширен пятью конкретными классами. Двумя наиболее важными классами среди них являются ConsoleHandler и FileHandler.
 *
 * ConsoleHandler записывает сообщения журнала в System.err, а FileHandler записывает сообщения журнала в файл.
 *
 * Обычно обработчик использует форматтер для форматирования сообщения журнала. В пакете журналирования есть два типа форматтеров. Это SimpleFormatter и XMLFormatter.
 *
 * Конечно, оба они расширяют абстрактный класс Formatter в пакете журналирования.
 *
 *
 * Фильтры
 *
 * Когда мы разрабатываем программное приложение, мы записываем как можно больше сообщений журнала. Но мы не хотим, чтобы все сообщения журнала выполнялись при каждом запуске приложения: это будет тратить ресурсы и может привести к созданию неоправданно длинных файлов журнала. Поэтому мы используем фильтры.
 *
 * Допустим, вы хотите печатать только информационные сообщения. Для этого сначала вам необходимо создать собственный класс фильтра, реализовав интерфейс фильтра в пакете журналирования.
 *
 * Итоги:
 *
 * Во-первых, java.util.logging является частью Java SDK и отвечает за предоставление разработчикам возможностей ведения журналов.
 *
 * Экземпляры Logger отвечают за создание сообщений журнала. Обычно мы создаём экземпляр регистратора для каждого класса, в который собираемся добавлять журналы.
 *
 * Обработчики отвечают за отправку сообщений журнала из приложения.
 *
 * Если вы хотите распечатать сообщения журнала на консоль, используйте ConsoleHandler.
 *
 * Если вы хотите записывать сообщения журнала в файл, используйте FileHandler.
 *
 * Средства форматирования форматируют сообщения журнала.
 *
 * Если вы хотите регистрировать сообщения в формате XML, используйте XMLFormatter.
 *
 * Наконец, фильтры, которые помогают контролировать, какие журналы должны выполняться при запуске приложения.
 */
fun logging() {
    println("--- log() ---")

    // Создаём экземпляр регистратора
    val logger = Logger.getLogger(Main::class.java.name)

    // Вызываем метод log(), чтобы распечатать сообщение журнала
    // Метод log() принимает два аргумента: первый аргумент — объект уровня, а второй — сообщение.
    // Level.WARNING — это константа из класса Level в пакете журналирования.

    // сент. 27, 2023 12:42:36 PM Main main
    // WARNING: Hello Main
    logger.log(Level.WARNING, "Hello ${logger.name}") // WARNING: Hello Main

    // Отдельный метод под каждый уровень

    // сент. 27, 2023 12:42:36 PM DebuggingKt logging
    // SEVERE: Severe Log message
    logger.severe("Severe Log message")

    // сент. 27, 2023 12:42:36 PM DebuggingKt logging
    // WARNING: Warning Log message
    logger.warning("Warning Log message")

    //сент. 27, 2023 12:42:36 PM DebuggingKt logging
    // INFO: Info Log message
    logger.info("Info Log message")

    logger.config("Config Log message")
    logger.fine("Fine Log message")
    logger.finer("Finer Log message")
    logger.finest("Finest Log message")

    println("--- Handlers and formatters ---")

    /**
     * В корне будет создан файл журнала с именем default.log, который будет содержать текст XML
     */
    val fileHandler: Handler = FileHandler("default.log")

    logger.addHandler(fileHandler)

    fileHandler.formatter = XMLFormatter()

    // сент. 27, 2023 11:26:55 PM DebuggingKt logging
    // INFO: Info log message
    logger.info("Info log message")

    println("--- Filters ---")

    val filter: Filter = FilterExample()

    logger.filter = filter

    /**
     * Когда этот код будет выполнен, будет напечатано только сообщение информационного журнала
     */
    logger.severe("Severe Log")
    logger.info("Info Log")
    logger.warning("Warning Log")

    handlerClasses()
}

/**
 * Дан список уровней журнала, разделённых пробелами.
 *
 * Найдите общее целое значение данного набора уровней журнала.
 */
fun handlerClasses() {
    val list = "info severe".split(" ")

    val sum = list.sumOf {
        Level.parse(it.uppercase()).intValue()
    }

    println(sum)// 1800
}

/**
 * Как видите, мы не ссылаемся напрямую ни на один класс Logback. Вместо этого мы вызываем классы и интерфейсы SLF4J, а SLF4J, в свою очередь, делегирует операции журналирования Logback.
 */
class ExampleLogback {
    /**
     * При создании регистратора мы используем метод getLogger, который принимает в качестве аргумента либо класс, либо строку.
     *
     * В обоих случаях аргумент используется как имя регистратора. Если регистратор с таким именем уже существует, метод возвращает тот же регистратор, а если регистратора с таким именем нет, создается новый.
     */
    private val log1: LogbackLogger = LoggerFactory.getLogger(Example::class.java)
    private val log2: LogbackLogger = LoggerFactory.getLogger("com.example.Example")

    init {
        /**
         * Объект Logger имеет ряд методов, а именно trace, debug, info, warn и error для вывода сообщения соответствующего уровня запроса журнала.
         */
        // 00:51:37.012 [main] INFO Example -- Information from LOG_1
        log1.info("Information from LOG_1")

        // 00:51:37.018 [main] WARN com.example.Example -- Warning from LOG_2
        log2.warn("Warning from LOG_2")

        // 00:51:37.018 [main] INFO Example -- Are the loggers the same? false
        log1.info("Are the loggers the same? {}", log1 === log2)
    }
}


/**
 * Logback - популярная библиотека журналирования
 *
 * Она является преемником библиотеки журналирования Log4j и основана на аналогичных концепциях. Logback работает быстро как при синхронном, так и при асинхронном журналировании и предлагает множество полезных функций, что делает его хорошим выбором для проекта любого масштаба.
 *
 * Наиболее важное различие между использованием средства ведения журнала Logback и простой печатью сообщения в System.out заключается в том, что у каждого средства ведения журнала есть контекст.
 *
 * Контекст журнала позволяет включать или отключать определённые сообщения журнала и отвечает за создание экземпляров журнала и организацию их иерархии.
 *
 * Чтобы начать работу с Logback, нужно добавить зависимость logback-classic.
 *
 * `dependencies {
 *     testImplementation("ch.qos.logback:logback-classic:1.4.11")
 * }`
 *
 * Эта библиотека будет транзитивно извлекать две другие зависимости: slf4j-api и logback-core.
 *
 * SLF4J (Simple Logging Facade for Java) — это фасад или абстракция для различных библиотек журналирования, включая Logback. Он предоставляет простой API для ведения журналов, и Logback реализует его изначально. Вы можете вызвать регистратор SLF4J с Logback в качестве базовой реализации без каких-либо накладных расходов.
 *
 * Библиотека logback-core закладывает основу для Logback и предоставляет для использования несколько готовых классов.
 *
 * Таких, как:
 *
 * - ConsoleAppender, который добавляет события журнала в System.out или System.err;
 *
 * - FileAppender, который добавляет события журнала в файл;
 *
 * - RollingFileAppender, который добавляет события журнала в файл и может изменить цель журнала на другой файл при выполнении определённого условия.
 *
 * Библиотека logback-classic предоставляет классы, позволяющие отправлять данные во внешние системы.
 *
 * Таких, как:
 *
 * - SMTPAppender, который собирает данные в пакеты и отправляет содержимое пакета на указанный пользователем адрес электронной почты после возникновения указанного пользователем события;
 *
 * - DBAppender, который добавляет данные в таблицы базы данных.
 *
 * По умолчанию каждая строка журнала содержит следующие элементы: метку времени, имя потока, уровень запроса журнала, имя средства ведения журнала и сообщение журнала.
 *
 * Точная настройка конфигурации логгера
 *
 * Чтобы настроить регистраторы в Logback, вы можете использовать XML-файл или файл Groovy.
 *
 * Мы настроим наш регистратор с помощью XML-файла. Вам нужно будет создать файл logback.xml и поместить его в папку ресурсов. Вот как будет выглядеть файл основных настроек:
 *
 * `<configuration>
 *     <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
 *         <encoder>
 *             <pattern>%d{HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
 *         </encoder>
 *     </appender>
 *
 *     <root level="info">
 *         <appender-ref ref="console" />
 *     </root>
 * </configuration>`
 *
 * Все настройки логгера записываются между тегами <configuration>.
 *
 * Далее идёт тег <appender>.
 *
 * Appender — инструмент, позволяющий настроить, где и как будут записываться логи.
 *
 * Параметр name указывает имя приложения, а параметр class указывает класс, который будет реализовывать приложение.
 *
 * Тег <encoder> определяет формат, в котором будут записываться журналы. Сообщение журнала в формате, который мы определили выше, будет выглядеть так:
 *
 * 01:15:54 INFO  com.example.Example - Customized message format
 *
 * Тег <root> относится к предопределённому корневому регистратору. Здесь мы указали уровень журнала level="info", и к нему был привязан аппендер <appender-ref ref="console" />.
 *
 * В верхней строке настроек вы можете заметить, что мы использовали ConsoleAppender. Это приложение позволяет выводить логи в консоль.
 *
 * Еще одно стандартное приложение — FileAppender. Как можно догадаться по названию, это приложение позволяет записывать логи в файл.
 *
 * `<configuration>
 *     <appender name="file" class="ch.qos.logback.core.FileAppender">
 *         <file>${user.dir}/logs/example.log</file>
 *         <encoder>
 *             <pattern>%d{HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
 *         </encoder>
 *     </appender>
 *
 *     <root level="info">
 *         <appender-ref ref="file" />
 *     </root>
 * </configuration>`
 *
 * Это самая примитивная настройка FileAppender. Новинкой в ​​настройках является тег <file>, в котором мы указываем, где находится файл и куда мы хотим вести запись логов. Не волнуйтесь, если этого файла нет — он будет создан при запуске приложения. Благодаря ${user.dir} файл журнала появится в основной папке проекта.
 *
 * Logback позволяет настроить уровень журнала для отдельных пакетов и классов.
 *
 * Для этого вам нужно будет перейти к файлу logback.xml, а затем указать имя и уровень параметров. В параметре name укажите путь к пакету или классу в вашем проекте, а в параметре level укажите необходимый вам уровень логирования.
 *
 * `<logger name="com.example.ExampleLogback" level="warn"/>`
 *
 * Каждый регистратор будет выводить только те сообщения, уровень запроса журнала которых выше или равен уровню регистратора.
 *
 * В Logback существует иерархия, основанная на именах. То есть, если у нас есть регистратор с именем `com.logback.first`, он будет родительским для регистратора с именем `com.logback.first.second`, который является родительским для `com.logback logger.first.second.third`.
 *
 * Это означает, что вы можете определить уровни ведения журнала для целых пакетов. На вершине каждой иерархии находится корневой регистратор.
 */
fun logback() {
    println("--- Basic logging ---")

    ExampleLogback()
}

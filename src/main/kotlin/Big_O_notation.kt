/**
 * Предположим, вам нужно выбрать один из нескольких алгоритмов для решения задачи. Как выбрать лучший? Для этого нужно как-то измерить эффективность алгоритма.
 *
 * Одним из вариантов может быть измерение времени, необходимого вашей программе для обработки ввода. Однако разным компьютерам может потребоваться разное время для обработки одних и тех же данных. Кроме того, время обработки может зависеть от самих данных. Нам явно нужно что-то более универсальное.
 *
 * Итак, давайте попробуем оценить эффективность, используя Big O notation.
 *
 * Время работы алгоритма зависит от входных данных. Естественно, программе потребуется разное время, чтобы обработать 10 или 1 000 000 номеров. Мы будем использовать термин «размер входных данных» в качестве прокси-меры размера входных данных.
 *
 * Если вам нужно работать с m числами, то m — это входной размер.
 *
 * Размер ввода не всегда является объёмом самих входных данных. Если вам нужно найти первые n простых чисел, то поиск 10 первых простых чисел или 10 000 первых простых чисел также займёт другое время, однако вы вводите в качестве входных данных только одно число n. В таких случаях значение этого числа обычно считается размером ввода.
 */
fun main () {
    /**
     * Что обычно делает алгоритм? Делает некоторые расчёты. Операциями будем называть базовые действия, такие как сложение, умножение, сравнение, присваивание переменных и т.д.
     *
     * Конечно, время вычислений зависит от машины, но сейчас это не имеет значения, потому что мы хотим сравнивать алгоритмы, а не машины.
     *
     * Если мы сможем оценить, как количество операций в алгоритме зависит от размера входных данных, мы получим машинно-независимую меру сложности алгоритма.
     *
     * Менее формально мы можем сказать, что алгоритм имеет временную сложность O(f(n)), если число его операций растёт аналогично (или медленнее) функции f(n), когда входной размер n является большим числом.
     */

    /**
     * Во избежание излишней абстрактности рассмотрим следующую задачу: дана таблица размера n×n с целыми числами в ячейках. Найдите число k в данной таблице.
     *
     * Алиса и Боб придумали собственные алгоритмы для решения задачи.
     *
     * Алгоритм Боба состоит в том, чтобы просмотреть каждую ячейку таблицы и проверить, равно ли соответствующее значение k. Ну, это подразумевает максимум n^2 сравнений, что означает, что временная сложность алгоритма Боба составляет O(n^2).
     *
     * С другой стороны, Алиса каким-то образом заранее знает, в каком столбце будет находиться число k, поэтому ей нужно просмотреть только элементы этого столбца. Столбец состоит из n ячеек, что означает, что алгоритм Алисы займет время O(n).
     *
     * По сути, на столе 2×2 Бобу придётся выполнить максимум 4 операции. Между тем, Алиса выполнит не более 2.
     *
     * Не большая разница, правда? Что, если у нас есть таблица n×n для большого n? В этом случае n^2 будет значительно больше n.
     *
     * Именно это определяет эффективность алгоритма — то, как он ведёт себя при больших размерах входных данных.
     *
     * Следовательно, мы заключаем, что алгоритм Алисы быстрее, чем алгоритм Боба, как предполагает нотация большого О.
     *
     * Однако возникает простой вопрос: почему мы не можем писать просто n^2 или n для сложностей? Зачем нам нужно добавлять эту красивую круглую букву перед этими функциями?
     *
     * Итак, представьте, что элемент k помещён в первую ячейку таблицы. Боб немедленно найдет его и завершит свой алгоритм. Сколько шагов он делает – n^2? Нет, только один.
     *
     * Вот почему мы используем Big O: грубо говоря, он описывает верхнюю границу скорости роста функции. Это одно из существенных преимуществ нотации Big O.
     *
     * Это означает, что вы можете рассчитать, сколько времени выделить на обработку определённого количества входных данных и быть уверенным, что алгоритм всё это обработает в своё время.
     *
     * На практике алгоритм иногда может работать даже лучше, чем то, что показывает нотация Big O, но не хуже.
     */

    /**
     * Общие темпы роста
     *
     * Ниже приведены, от лучшего к худшему, некоторые общие значения функции Big O для временной сложности, также известные как классы сложности.
     *
     * - O(1) (постоянное время). Алгоритм выполняет постоянное количество операций. Может быть, один, два, двадцать шесть или двести – неважно. Важно то, что это не зависит от размера ввода. Типичные алгоритмы этого класса включают вычисление ответа по прямой формуле, вывод пары значений, всех букв английского алфавита и т.д.
     *
     * - O(log n) (логарифмическое время). Возможно, необходимо быстро напомнить о логарифмах. Обычно мы ссылаемся на логарифмы по основанию 2; однако база не влияет на класс.
     *
     * По определению, log2 n равно количеству раз, которое нужно разделить n на 2, чтобы получить 1. При этом нетрудно догадаться, что такие алгоритмы делят размер ввода пополам на каждом шаге. Они относительно быстрые: если размер входных данных огромен, скажем, 2^31 (программисты должны знать важность этого числа), алгоритм выполнит приблизительно log2(2^31)=31 операцию, что довольно эффективен.
     *
     * - O(n) (линейное время). Время пропорционально размеру входных данных, т.е. время растёт линейно по мере увеличения размера входных данных. Часто такие алгоритмы повторяются только один раз. Встречаются они довольно часто, потому что обычно перед вычислением окончательного ответа необходимо пройтись по каждому входному элементу. Это делает класс O(n) одним из самых эффективных классов на практике.
     *
     * - O(n^2) (квадратичное время). Обычно такие алгоритмы перебирают все пары входных элементов.
     *
     * Почему? Что ж, математика щедра, она постоянно даёт нам важные результаты: в данном случае базовая математика подтверждает, что количество неупорядоченных пар в множестве из n элементов равно (n * (n−1)) / 2, что равно O(n^2).
     *
     * Если вам это страшно или трудно понять, это совершенно нормально, это случается с лучшими из нас. С другой стороны, тем, кто знаком с терминами программирования, может пригодиться следующее предложение: алгоритмы квадратичного времени обычно содержат два вложенных цикла.
     *
     * - O(2^n) (экспоненциальное время). На всякий случай отметим, что 2^n — это то же самое, что умножить 2 само на себя n раз. Опять же, математика утверждает, что количество подмножеств множества из n элементов равно 2^n, поэтому разумно ожидать, что такие алгоритмы сканируют все подмножества входных элементов.
     *
     * Стоит отметить, что на практике этот класс крайне неэффективен; даже для небольших входных данных время, затрачиваемое алгоритмом, будет очень большим.
     *
     * Существуют и другие, менее распространенные классы сложности:
     *
     * - O(sqrt n) (время квадратного корня);
     * - O(n log n) (логарифмическое линейное время);
     * - O(n^k) (полиномиальное время);
     * - O(n!) (факторное время).
     */

    /**
     * От быстрых (слева) к медленным (справа)
     *
     * O(1) <- O(log n) <- O(sqrt n) <- O(n) <- O(n log n) <- O(n^2) <- O(2^n) <- O(n!)
     */

    /**
     * Основные свойства большого О:
     *
     * - Не обращайте внимания на константы.
     *
     * При расчёте сложности мы фокусируемся исключительно на поведении нашего алгоритма при больших размерах входных данных. Поэтому повторение некоторых шагов постоянное количество раз не влияет на сложность. Например, если вы проходите n элементов 5 раз, мы говорим, что временная сложность алгоритма составляет O(n), а не O(5n).
     *
     * Действительно, нет существенной разницы между 1 000 000 000 и 5 000 000 000 операций, выполняемых алгоритмом. В любом случае мы делаем вывод, что это относительно медленно.
     *
     * Формально мы пишем c⋅O(n)=O(n). Он аналогичен остальным классам сложности.
     *
     * - Применение процедуры n раз.
     *
     * Что делать, если вам нужно просмотреть n элементов n раз? Это больше не константа, так как зависит от размера ввода. В этом случае временная сложность становится O(n^2). Всё просто: вы делаете n раз действие, пропорциональное n, а значит, результат пропорционален n^2. В нотации Big O мы записываем это как n⋅O(n)=O(n^2).
     *
     * - Меньшие сроки не имеют значения.
     *
     * Ещё один распространённый случай, когда после выполнения одних действий нужно сделать что-то ещё.
     *
     * Например, вы проходите n элементов n раз, а затем снова проходите n элементов. В этом случае сложность по-прежнему O(n^2). Дополнительные действия n не влияют на вашу сложность, которая пропорциональна n^2.
     *
     * В нотации Big O это выглядит так: O(n)+O(n^2)=O(n^2).
     *
     * В общем, всегда держите самый большой член в Big O и забудьте обо всех остальных.
     */
}
